# Example workflow: 'Compress and encrypted external emails'
# 
#
# This workflow uses the SMTP listener service. The workflow receives an email as a
# CloudEvent from the SMTP listener. The workflow will compress & encrypt the attachments
# with a random password and email this to all external email addresses. For internal email
# addresses no encryption or compression occurs. Once completed, the workflow sends the
# password to a mobile address defined in the format 61404193552@direktiv.local
#
#
# Medium article: https://medium.com/@wilhelm-wonigkeit/direktiv-encrypting-server-side-email-attachments-in-the-real-world-d18a7bccb36c
#
# Inputs:
# { }
# 
#

description: "Listens for an SMTP-event, zips the email attachments for external addresses and generates a random pasword for the internal email address"

# This workflow is event-driven, which means it will 
# only kick-off when an smtp event is received on the 
# namespace. It will transition to the 'set-attachments'
# state as a start
start:
  type: event
  state: set-attachments
  event:
    type: smtp

# The zip function will zip and encrypt the object 
# The gen-pw function will generate a random password
functions:
  - id: zip
    image: vorteil/zip:latest
    type: reusable
    files:
    - key: attachments
      scope: instance
      as: attachments.json
      type: plain
  - id: genpw
    image: vorteil/gen-pw:latest
    type: reusable
  - id: send-email
    type: subflow
    workflow: send-email

states:
  # The state stores the attachments as internal variables 
  # which can be manipulated and stored as required. It 
  # transitions to the 'gen-password' state.
  - id: set-attachments
    type: setter
    variables:
    - key: attachments
      scope: instance
      value: jq(.smtp.attachments)
    transition: gen-password

  # The state generates the random password. The password 
  # complexity can be set wihtin the state. 
  - id: gen-password
    type: action
    action:
      function: genpw
      input:
        length: 10
        symbols: 0
        digits: 3
    transform:
      smtp: jq(.smtp)
      password: jq(.return.password)
    transition: zip-data

  # The state zips all of the attachments with the provided 
  # password (generated in the 'gen-password' state previously). 
  # The JSON object transformed contains all of the data previously 
  # received from the SMTP listener, including the zipped 
  # attachments and password
  - id: zip-data
    type: action
    #log: jq(.)
    transform:
      data: jq(.return)
      smtp: jq(.smtp)
      password: jq(.password)
    action:
      function: zip
      input:
        password: jq(.password)
        file: attachments.json
    transition: send-email
    
  # For each of the email addresses in the "To" field,
  # execute the sub workflow to send the email. 
  - id: send-email
    #log: jq(.)
    type: foreach
    array: 'jq({email: .smtp.to[], data: .data, password: .password, attachments: .smtp.attachments, internal: .smtp.internal, message: .smtp.message, subject: .smtp.subject})'
    action:
      function: send-email
      input:
        email: jq(.email)
        data: jq(.data)
        password: jq(.password)
        attachments: jq(.attachments)
        internal: jq(.internal)
        message: jq(.message)
        subject: jq(.subject)

